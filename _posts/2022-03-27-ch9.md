---
layout: single
title: "Warming-up C programming ch10"
categories: coding
---







# 개념정리

### 1. 구조체의 기본

1. 구조체의 개념

   - 구조체는 서로 다른 데이터형의 변수들을 하나로 묶어서 사용하는 기능
   - 구조체는 C언어에서 사용자 정의형을 만드는 방법

2. 구조체의 정의

   - ```c
     struct content {
         char title[40];
         int price;
         double rate;
     }
     ```

   - 태그이름 (ex. content) : 구조체를 구별하기 위한 이름

   - 구조체의 멤버, 구조체 정의 끝을 나타내는 세미클론

   - 구조체 정의 시 새로운 데이터형이 만들어짐

   - 구조체형의 변수를 선언해야 구조체 변수가 메모리에 할당

   - 구조체의 바이트 크기는 멤버들의 바이트 크기를 모두 더한 것보다 크거나 같다

     - 메모리 정렬
     - 패딩 : c/c++ 컴파일러는 정렬도니 주소에 구조체를 할당하기 위해 멤버 사이에 사용되지 않은 데이터 바이트를 삽입하기도 함

   - 구조체 사용 시 struct 키워드와 태그 이름을 함께 사용

     - ```c
       printf("%d", sizeof(content)); //content가 구조체 이름이라는 것을 알 수 없음
       ```

3. 구조체 변수의 선언 및 초기화

   - ```c
     struct content movie; //struct 태그명 변수명
     ```

   - 구조체 변수를 선언하면 구조체의 멤버들이 선언된 순서대로 메모리에 할당됨

   - 구조체 변수 초기화 시 {} 안에 멤버들의 초기값을 선언된 순서대로 나열한다. (초기화 하지 않으면 쓰레기값 가짐)

4. 구조체 변수의 사용

   - 구조체 멤버에 접근하려면 멤버 접근 연산자(.) 사용

5. 구조체 변수 간의 초기화와 대입

   - 같은 구조체형 변수들끼리 서로 초기화하거나 대입할 수 있음

   - ```c
     struct content c2 = c1; //같은 멤버끼리 1:1로 복사해서 초기화한다.
     c3 = {"aqua", 500, 7.1}; // 대입에는 {}를 사용할 수 없음
     c3.title = c1.title; // 구조체의 멤버인 배열끼리는 대입할 수 없음
     strcpy(c3.title, c1.title); // title이 문자 배열 이므로 문자열 처리함수를 이용
     ```

6. 구조체 변수의 비교

   - 구조체 변수에는 관계 연산자를 사용할 수 없음

   - 구조체의 변수의 값이 같은지 비교하려면 멤버 대 멤버로 비교해야 함

   - ```c
     if(c1 == c2) // 구조체 변수에 관계 연산자를 사용하면 컴파일 에러
     if(strcmp(c1.title, c2.title) == 0 && c1.price && c2.price && c1.rate == c2.rate) // 멤버 대 멤버로 비교    
     ```





### 2. 구조체의 활용

1. 구조체 배열

   1. 구조체 배열의 선언 및 사용

      - ```c
        struct content arr[3]; //크기가 3인 content 구조체 배열
        struct content arr[] = {
            {"aven", 1100, 8.8},
            {"aqua", 550, 7.1},
            {"shaz", 77., 7.4}
        };
        for(i = 0; i <size ; i++)
            printf("arr[%d] = %s, %d, %.1f\n",i,arr[i].title,arr[i].price,arr[i].rate)
        ```

      - 구조체 배열의 원소들 메모리에 연속적으로 할당됨

      - 구조체 배열 초기화 시 {} 안에 배열 원소의 초기값을 나열하고 배열의 크기 생략 가능

      - arr가 구조체 배열의 이름일 때 구조체의 멤버에 접근하려면 arr[i].member로 접근한다.

   2. 구조체 배열의 활용

      - 구조체 배열에 대해서 데이터의 탐색과 정렬같은 기능 구현 가능

2. 구조체 포인터

   - 구조체 포인터는 구조체 변수의 주소를 저장하는 포인터

   - 구조체 포인터 ptr이 가리키는 구조체 변수의 멤버에 접근하려면 `ptr->member` 또는 `(*ptr).member`를 사용

   - ```c
     p->rate = 8.9; //간접 멤버 접근 연산자 ->를 이용해 멤버 접근
     (*p).rate = 8.9; //역참조 연산자 *와 멤버 접근 연산자 .를 이용하는 경우에는 반드시 ()가 필요
     ```

3. 함수의 인자로 구조체 전달하기

   1. 값에 의한 호출
      - 기본형에 비해 크기가 큰 구조체는 복사하는 대신(값에 의한 호출) 구조체의 주소를 전달하는것이 좋음
   2. 참조에 의한 호출
      - 구조체를 복사하지 않고 전달하기위해 포인터로 전달
      - 구조체가 입력 매개변수일 때는 const포인터로 전달하는 것이 좋음
      - 구조체가 함수의 출력 매개변수이거나 입출력 매개변수일 때는 일반 포인터 전달
   3. 구조체를 함수의 인자로 전달하는 방법
      1. 함수의 매개변수는 구조체 포인터형으로 선언
      2. 구조체 변수가 입력 매개변수 일 때는 const 키워드 지정
      3. 구조체를 매개변수로 갖는 함수를 ㅎ출할 때는 구조체 변수의 주소를 인자로 전달
      4. 함수를 정의할 때는 구조체 포인터로 구조체의 멤버에 접근

4. 구조체의 멤버로 다른 구조체 사용하기

   - 구조체 안에 다른 구조체 변수를 멤버로 포함할 수 있음



### 3. 열거체와 공용체

1. 열거체

   1. 열거체의 개념

      - 열거체는 정수형의 일종으로 열거형이라고도 함
      - 열거체와 열거 상수를 이용하면 정수형 상수를 보다 쉽게 정의하고 사용 가능

   2. 열거체의 정의 및 사용

      - 열거 상수 : 이름이 있는 정수형 상수

      - ```c
        enum color {red, green, blue};
        enum direction {
            north, south, east, wet
        };	//열거체와 열거 상수 정의
        ```

      - C컴파일러는 열거체를 int형으로 처리하고 열거 상수를 정수형 상수로 정의

      - 특정값으로 정의하려면 열거상수 다음에 =을 쓰고 값을 써줌

      - 열거상수는 지정된 값보다 1씩 커지는 정수값으로 자동으로 설정

2. 공용체

   - 여러멤버들이 메모리를 공유해서 사용하는 기능

   - 공용체의 멤버들은 모두 같은 주소에 할당된다

   - ```c
     union color_t {
         unsigned int dd;
         unsigned char rgb[4];
     };
     ```

   - 공용체의 크기는 멤버 중 가장 큰 멤버의 크기와 같다

3. typedef

   - typedef이용 시 기존의 데이터형에 대한 별명을 만들 수 있다.

   - ```c
     struct point {
         int x,y;
     };
     typedef struct point point_t; //point 구조체에 대해 typedef를 정의함, point_t가 struct point의 별명
     point_t pt1 = {10, 20}; //struct_point 대신 point_t 사용 가능
     ```

   - 구조체를 정의하면서 typedef를 함께 정의하는 방법

   - ```c
     typedef struct point {	//point 구조체를 정의하면서 typedef를 함께 정의
         int x, y;
     } point_t;
     ```





# 프로그래밍 과제
