---
layout: single
title: "[n113] Data Wrangling"
categories: review
tag: [코드스테이츠, python]
toc: true
---









# 개념정리 



## Data Wrangling

### 데이터 탐색

1. 데이터 품질의 문제
   - 데이터 content issue : 중복, 결측치, 부정확한 데이터 등
   - 이슈 확인 방법
     - 시각적 탐색 : text editor, google sheet와 같이 프로그램 활용해 데이터 셋을 관찰
     - 프로그래매틱 탐색 : info() 등과 같은 코드 사용해 전체적인 데이터 확인
2. 데이터 구조의 문제
   - 데이터 structual issue 
     1. 각 변수는 하나의 열을 구성
     2. 각 관측치는 하나의 행을 구성
     3. 각 유형의 관측 단위가 표를 구성

### 데이터 정제

품질의 문제 해결 > Missing values 채워 넣기 > Duplicates 해결 > 구조적 문제 해결

1. 문제 정의 : 어떻게 정제할 지 정의
2. 코드 구현 : 정제하기 위한 코드를 짜기
3. 결과 확인 : 잘 정제가 되었는지 테스트







## 함수

### str.contains

- ```python
  Series.str.contains(string/pattern, case=True/False, regex=True/False)
  ```

- **string/pattern** : 찾을 문자열 또는 패턴

- **case** : True일 경우 case sensitive(대소문자 구분), False일 경우 case insensitive(대소문자 구분 안함)

- **regex** : True일 경우 string/pattern을 regular expression pattern으로 인식. False일 경우 string/pattern을 문자 그대로 인식.









## 결측치 처리방법

### 결측치 종류

- 완전 무작위 결측(MCAR: Missing completely at random)
  - 변수 상에서 발생한 결측치가 다른 변수들과 아무런 상관이 없는 경우 (ex. 깜빡하고 입력안함, 전산오류 등)

- 무작위 결측(MAR : Missing at random)
  - 결측치 발생 확률이 관측값에만 의존하고 결측치가 발생하지 않는 변수에는 의존하지 않는다는 가정 (ex. 남성은 우울증 설문 조사에 기입할 확률이 낮지만 우울함 정도와는 상관이 없는 경우)

- 비 무작위 결측(MNAR: Missing at not random) 
  - 위 두가지 유형이 아닌 경우, 누락된 값이 다른 변수와 연관이 있는 경우(ex. 남성이 우울증 설문 조사에 기입하는 게 우울증의 정도와 관련이 있는 경우)


### 결측치 처리 가이드 라인

- 흔히 알려진 경우

  - > 10% 미만 : 삭제 or 대치
    >
    > 10 ~ 20% : *Hot dect*(매년 자료->해당년도 자료로 추정) or *regression* or *model based imputation*
    >
    > 20 ~ 50% : *regression* or *model based imputation*
    >
    > 50% : 해당 칼럼 자체 제거



### 결측치 처리 방법

#### 제거법

- 완전 제거법 : 결측치 존재 행 자체 삭제
- 한쌍 제거법 : 결측 포함한 응답자를 분석에서 제외 후 남아있는 관측치에 대해 분석 진행

-> 단점 : 표본의 수가 줄어들어 통계적 검정력이 떨어짐

-> 충분한 데이터가 존재할 때 사용 `.dropna()`



#### 단일 대체법

결측치를 삭제하지 않고 특정 값을 넣어줌

- 가지고 있는 데이터를 통해 결측치 값을 유추할 수 있고 중요한 데이터라서 삭제할 수 없는 경우

- 평균 대체 : 결측치를 평균으로 대체, 그러나 표준오차가 과소 추정되고 해당 변수의 분산을 작게하는 문제와 함께 다른 변수와의 상관관계를 낮추는 등의 분석 결과에 문제가 생길 수 있음
- 회귀 대체 : 평균대체와 달리 설명변수의 조건부 평균으로 결측을 대체
- `fillna()`



#### 다중 대체법

가능한 대체 값의 분포에서 추출된 서로 다른 값으로 결측치를 처리한 복수의 데이터 셋을 생성한 다음 이에 대해 각각 분석을 수행하고 그 결과로 얻은 모수의 추정량과 표본오차를 통합해 하나의 분석 결과를 제시하는 방법









## 정규표현식

### re 모듈

- 정규 표현식을 지원하기 위한 모듈, 파이썬 설치 시 자동 설치되는 기본 라이브러리

- ```python
  import re
  p = re.compile('ab*') # 객체 p는 컴파일된 패턴 객체
  ```



### 메타문자

- 메타 문자
  - 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는 문자

#### 문자 클래스 []

- 문자 클래스로 만들어진 정규식은 *"[ ] 사이의 문자들과 매치"*라는 의미를 가짐 
  - [abc] : a, b, c 중 한개의 문자와 매치 -> "a", "before" 은 매치되지만 "dude" 는 안됨
- []안에 - 사용 시 두 문자 사이의 범위(From - To) 를 의미
  - [a-c] == [abc]
  - [0-5] == [012345]
  - [a-zA-Z] : 알파벳 모두
  - [0-9] : 숫자
- 자주 사용하는 문자 클래스
  - `\d` == `[0-9]` : 숫자와 매치
  - `\D` == `[^0-9]` : 숫자가 아닌 것과 매치
  - `\s` == `[ \t\n\r\f\v]` : whitespace 문자와 매치, 맨 앞 빈칸은 공백문자를 의미
  - `\S` == `[^ \t\n\r\f\v]` : whitespace 문자가 아닌 것과 매치
  - `\w` == `[a-zA-Z0-9_]` : 문자+숫자와 매치
  - `\W` == `[^a-zA-Z0-9_]` : 문자+숫자가 아닌 문자와 매치



#### Dot(.)

- 줄바꿈 문자인 \n을 제외한 모든 문자와 매치
- `a.b` : a + 모든 문자 + b 
  - aab, a0b 가능
  - abc 불가능
- `a[.]b` : a + Dot(.)문자 + b
  - a.b 가능
  - a0b 불가능
  - 문자 클래스 안에 Dot(.)메타문자가 사용되면 모든 문자라는 의미가 아닌 문자 그대로를 의미



#### 반복

##### (*)

- `*` 바로 앞에 있는 문자가 0부터 무한대로 반복될 수 있음
- `ca*t`
  - ct : a가 0번 반복되어 매치
  - cat : a가 1번 반복되어 매치(1번 반복)
  - caaat  : a가 0번 이상 반복되어 매치 (3번 반복)

##### (+)

- `*`가 반복횟수 0부터라면 `+`는 반복횟수 1부터
- `ca+t` : c + a(1번 이상 반복) + t
  - ct : a가 0번 반복되어 매치x
  - cat : a가 1번 반복되어 매치(1번 반복)
  - caaat  : a가 0번 이상 반복되어 매치 (3번 반복)



##### ({m,n}, ?)

- 반복횟수 고정 (m회부터 n회까지)
- {m} : `ca{2}t`
  - c + a(반드시 2번 반복) + t
    - cat : a가 1번만 반복되어 매치되지 않음
    - caat : a가 2번 반복되어 매치
- {m, n} : `ca{2,5}t`
  - c + a(2~5회 반복) + t
    - cat : a가 1번만 반복되어 매치안됨
    - caat : a가 2번 반복되어 매치
    - caaaaat : a가 5번 반복되어 매치
- `?`
  - {0, 1} 를 의미함
  - `ab?c`
  - a +b(있어도 되고 없어도 된다) + c
    - abc : b가 1번 사용되어 매치
    - ac : b가 0번 사용되어 매치





### 정규식을 이용한 문자열 검색



#### match

- 문자열의 처음부터 정규식과 매치되는지 조사 

- 도입에서 찾는 것임

  - life를 찾는데 human life 입력하면 못찾고
  - life of human은 찾음

- 정규식과 매치 시 객체 돌려줌

- ```python
  p = re.compile('[a-z]+')
  m = p.match("python") # match 객체 돌려줌
  n = p.match("3 python") # None
  ```



#### search

- 문자열 전체를 검색하여 정규식과 매치되는지 조사

- 정규식과 매치 시 객체 돌려줌

- ```python
  p = re.compile('[a-z]+')
  m = p.match("python") #match 객체 돌려줌
  n = p.match("3 python") # match 객체 돌려줌 python 문자열과 매치
  ```

- match 메서드와 search 메서드는 문자열의 처음부터 검색할지의 여부에 따라 다르게 사용해야 한다.



#### match 객체의 메서드

- group()

  - 매치된 문자열을 돌려준다

- start()

  - 매치된 문자열의 시작 위치를 돌려준다

- end()

  - 매치된 문자열의 끝 위치를 돌려준다

- span()

  - 매치된 문자열의 (시작, 끝) 에 해당되는 튜플을 돌려준다

- ```python
  # match
  >>> m = p.match("python")
  >>> m.group()
  'python'
  >>> m.start()
  0
  >>> m.end()
  6
  >>> m.span()
  (0, 6)
  
  
  # search
  >>> m = p.search("3 python")
  >>> m.group()
  'python'
  >>> m.start()
  2
  >>> m.end()
  8
  >>> m.span()
  (2, 8)
  
  #축약 코드
  >>> m = re.match('[a-z]+', "python")
  ```

  



#### findall

- 정규식과 매치되는 모든 문자열을 리스트로 돌려줌

- ```python
  p = re.compile('[a-z]+')
  result = p.findall("life is too short")
  print(result) # ['life', 'is', 'too', 'short']
  ```

  

#### finditer

- 정규식과 매치되는 모든 문자열을 반복 가능한 객체로 돌려줌

- ```python
  result = p.finditer("life is too short")
  print(result) #<callable_iterator object at 0x01F5E390>
  for r in result: print(r) # 반복 가능한 객체가 포함하는 각각의 요소는 match 객체임
  # <re.Match object; span=(0, 4), match='life'>
  # <re.Match object; span=(5, 7), match='is'>
  # <re.Match object; span=(8, 11), match='too'>
  # <re.Match object; span=(12, 17), match='short'>
  ```

  



#### 예제 코드

````python
>>>text = ```평생교육 실습 체험에 대한 내러티브 연구 (김진숙, 2012)
직업적 전문성과 직문의 탐구 (박지혜, 2003)
대학생의 평생교육 실습경험 탐색 (최희준, 2008)
```
>>> result = re.findall(r'\([A-Za-z가-힣]+, \d+\)', text)
>>> result
['(김진숙, 2012)', '(박지혜, 2003)', '(최희준, 2008)']
````

- `\(` : ( 을 나타냄 (정규식 안에 있는 문자라서 \ 붙여줌)
-  [A-Za-z가-힣] : 영문 또는 한글로 된 단어가 올 수 있다
- 가-힣 : 한글
- \d+ : 한자리 이상 숫자

```python
>>> sen = re.sub('\n', ' ', sen) # 줄바꿈 문자를 공백으로 바꿔줌
```







## pandas 매개변수 axis

- 판다스를 사용하다 보면 평균 계산, 데이터 프레임 열이나 행 삭제 작업 등을 할 때 axis(축)을 지정해야 함

### axis=0(index)

- 행 방향으로 동작

- 작업 결과가 행으로 나타남

- 책을 위로 쌓아 정리하는 것

- ```python
  #1,2행 삭제
  df.drop([1,2],axis=0)
  ```



### axis=1(columns)

- 열 방향으로 동작

- 작업 결과가 열로 나타남

- 책을 옆으로(세워서) 정리하는 것

- ```python
  #age, height 삭제
  df.drop(['age','height'],axis=1)
  ```









# 일일회고



## Keep (유지할 것)

- 늘 복습하는 습관!! 아무래도 방대한 양을 하루에 배워서 기억이 휘발휘발..(욕 아님), 이렇게 블로그에 5시에 강의 끝나면 바로 복습하자!
- 운동했다!! 유산소 운동 열심히 했다 (왜냐면 생일 케이크때무네 과식함 ㅋ) 계속 앉아있다가 나름 쉬는 용도로 운동했는데 아주 좋았다 ㅎㅎ 역시 나는 운동이 refresh 용도로 최고..



## Problem (문제점, 방해 요소)

-  불규칙한 식사... 아점저를 몰아서 먹는 아주 나쁜 습관... 고치자.. 아점저 소량씩 먹자! 왜냐면 과식하면 졸림 근데 아직까지 졸려서 존 적 한번도 없다! 왜냐면 그만큼 흥미롭고 재밌기 때문 (사실 이게 왜 안돼?! 이게 왜 돼??! 이러면서 맨날 머리 쥐어뜯음)
-  늦게 자고 늦게 일어나는 거.. 원래 내 목표는 오늘의 복습이 끝나면 30분만에 골아떨어지는 것을 원했는디 그냥 똘망똘망 새벽 2시까지 유튜브 커비영상만 열심히 봤다.. 쩝.. 그래서 8시에 기상..!!
-  과제 거의 다했다고 갑자기 놀아버림(?) 사실 뒤에 정리할 것이 산더미라서.. 나도 모르게 좀만 쉬자.. 이런 느낌으로 정규시간인데 놀았다... 하지만 점심시간 안쓰고 공부했으니까.. 나름 7시간정도는 집중했다..



## Try (시도할 것)

- 규칙적으로 아점저 다 챙겨먹기 : 건강식 위주로! 하루죙일 앉아있으니까 건강식이라도 먹어서 건강 지키자..
- 일찍 자고 일찍 일어나기 : 목표는 12시 반 취침 7시 반 기상! 이거 못지키면 수면시간은 6-8시간 지켜주기, 오히려 졸리면 능률 떨어진다
- 과제 끝냈다고 놀지 말고 부족했던 부분 보충하기







